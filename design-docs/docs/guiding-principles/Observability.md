
- [Observability](#observability)
- [OTEL](#otel)
- [Structured logging](#structured-logging)
- [Tracing](#tracing)
  - [Tools and Technologies for Tracing](#tools-and-technologies-for-tracing)
- [Metrics](#metrics)
- [Alerts](#alerts)
  - [Example](#example)
- [Tracing vs Logging](#tracing-vs-logging)
  - [Use Tracing When:](#use-tracing-when)
  - [Use Logging When:](#use-logging-when)
- [Diagnostics in .NET](#diagnostics-in-net)
- [Adding metrics to ProductsAPI](#adding-metrics-to-productsapi)
  - [Viewing metrics globally](#viewing-metrics-globally)
  - [Adding OTel](#adding-otel)
- [Best practices](#best-practices)
- [Resources](#resources)
- [Some questions](#some-questions)
- [ADD Aspire Project](#add-aspire-project)

## Observability
What is observability?

## OTEL

**Telemetry** is a combination of emitting logs and metrics from your code and then monitoring and analyzing the results. Unlike debugging, telemetry should not affect the operation and should have minimal impact on performance.

Logs are used to record a discreet operation and its success or failure. Metrics are used to record numbers, for example, completed requests, active requests, exceptions thrown, and so on.

**OpenTelemetry (OTel) **is an observability framework. It combines an API, an SDK, and tools that work together to generate and collect your solution’s telemetry data such as metrics and logs.

**Open Telemetry Protocol (OTLP) is a vendor-neutral network protocol for transmitting telemetry data with OTel.**

Since .NET provides its own logging API, you do not need to learn the OTel API. Instead, OTel integrates with ILogger. OTel requires the .NET 6 SDK or later.

The key benefits of using OTel with .NET projects are a common collection mechanism, common schemas and semantics for telemetry data, and an API for how third-party systems for analyzing data can integrate with OTel. These are called **exporters**. 

Common ones include **Prometheus** for metrics, **Grafana** for dashboards, and **Jaeger** for distributed tracing. 

Although you can manually configure these systems you will see how you can easily integrate OTel with your projects and get dashboards built in with Aspire.
//TODO: chapter 16 aspire


## Structured logging
structured logs use a standard format (like JSON) to represent log messages, making them easier to query and analyze. This approach allows you to attach additional context to each log message, such as user IDs, session info, or environment details. For example, Serilog is highly configurable and integrates with various sinks (outputs). It enables logs to be written to files, databases, or cloud services.

## Tracing
Tracing refers to the process of monitoring and recording the activity of a system or application to understand its behavior, diagnose issues, and optimize performance. Tracing captures detailed information about the execution flow, system calls, resource usage, and other events, enabling developers and administrators to gain insights into the inner workings of the system.

Tracing Events:

- Events are specific points in time where something significant happens in the system, such as function calls, exceptions, and context switches. These events are recorded and used to analyze the system's behavior.
Trace Logs:

- Trace logs are the records generated by tracing, containing detailed information about each event, including timestamps, event types, and context.
Instrumentation:

- Instrumentation involves inserting code into the system or application to generate trace events. This can be done manually by developers or automatically using tools.
Trace Visualization:

Tools and platforms often provide visualization features to help interpret trace data, such as timelines, graphs, and heatmaps.

### Tools and Technologies for Tracing
- **OpenTelemetry**: A set of APIs and tools for collecting distributed traces and metrics, providing standardized instrumentation for various programming languages.
- **Jaeger**:  An open-source tool for end-to-end distributed tracing, used for monitoring and troubleshooting microservices-based architectures.
- **Zipkin**: A distributed tracing system that helps gather timing data needed to troubleshoot latency problems in microservice architectures.
- **DTrace**: A comprehensive dynamic tracing framework for real-time diagnostics and troubleshooting in Unix-like operating systems.
- **strace**:A diagnostic, debugging, and instructional userspace utility for Linux to monitor the system calls used by a program and all the signals it receives.

## Metrics

Metrics are quantitative measurements used to track and analyze the performance, health, and behavior of your application or system. Common .NET metrics include:

Performance: CPU usage, memory consumption, request processing times, and so on.
Application: Number of requests per second, error rates, response times, and so on.
Custom: Any domain-specific measurements relevant to your application, such as the number of items processed, orders placed, or users logged in.
Metrics are collected over time and provide insights into the normal operation of your system. They help identify trends, diagnose issues, and optimize performance.

Common tools for recording and viewing metrics include:

- System.Diagnostics: A .NET built-in library for collecting performance counters.
- Prometheus: An open-source monitoring system often used with .NET applications via exporters.
- Grafana: A visualization tool that can be used with various data sources, including Prometheus.
Application Insights: A comprehensive monitoring service that can collect and analyze metrics from .NET applications. This requires Azure so we will not cover it in this book.

## Alerts

Alerts are notifications triggered by specific conditions or thresholds defined on metrics. They inform you when something unusual or potentially harmful happens in your application or system. Alerts help you respond to issues promptly, minimizing downtime and impact on users.

Common scenarios for alerts include:

- Threshold breaches: For example, if CPU usage exceeds 80% for more than 5 minutes
- Error rates: If the rate of HTTP 500 responses exceeds a certain percentage
- Custom conditions: Any specific conditions based on your custom metrics

Common tools for alerts include:

- Prometheus Alertmanager: Works with Prometheus to define alert rules and send notifications.
- Azure Monitor with Application Insights: Provides powerful alerting capabilities for Azure-hosted .NET applications. Supports setting up alerts based on the metrics collected.

### Example
Suppose you have a .NET web application. You might set up the following metrics and alerts:

Metric: Average response time of HTTP requests
Alert: When the average response time exceeds 2 seconds over a 5-minute period

Metric: Number of active users
Alert: When the number of active users drops below a certain threshold, indicating potential availability issues

Metric: Error rate of HTTP requests
Alert: When the error rate exceeds 5%, indicating possible application issues

## Tracing vs Logging


Tracing and logging are both essential techniques for monitoring and diagnosing applications, but they serve different purposes and provide different types of information. Here's a detailed comparison to understand their differences, uses, and benefits:


| Aspect                    | Tracing                                               | Logging                                              |
|---------------------------|-------------------------------------------------------|------------------------------------------------------|
| **Primary Purpose**       | Track execution flow and performance                  | Record specific events and system state              |
| **Detail Level**          | Detailed sequence of operations                       | Individual events or messages                        |
| **Use Cases**             | Performance analysis, debugging, distributed systems  | Error diagnosis, auditing, monitoring                |
| **Data Captured**         | Execution path, timings, context                      | Event details, error messages, information messages  |
| **Tools**                 | Jaeger, Zipkin, OpenTelemetry, DTrace                 | Log4j, Serilog, NLog, ELK Stack, Splunk              |
| **Scope**                 | Broad view of system behavior                         | Snapshot of specific events                          |
| **Visualization**         | Often includes visual tools for end-to-end tracing    | Log management systems for searching and analyzing   |

### Use Tracing When:

You need to understand the flow of requests through a complex system.
You are diagnosing performance issues and need detailed execution paths.
You are working with distributed systems and need to track requests across multiple services.

### Use Logging When:

You need to record errors, warnings, and informational messages.
You need to maintain an audit trail for security or compliance purposes.
You need to monitor the operational health and state of the system.

## Diagnostics in .NET

- `Meter` - The Meter class represents a named group of instruments (such as counters and histograms) that are logically related. It acts as a factory for creating these instruments and provides a scope for them. Each Meter has a name and a version.
- `Counter<T>` -class is a type of metric instrument that tracks the count of events or occurrences. It’s typically used for metrics that accumulate over time, such as the number of requests received or the number of errors encountered. `Counter<T>` is an accumulating metric and should be used when you need to record a value that only increases.
- `Histogram<T>` class is used to record the distribution of values, such as the duration of requests or the size of payloads. It helps in understanding the range and distribution of a set of measurements. You create a `Histogram<T>` through a Meter instance and use its Record method to log a value.


The classes are part of the `System.Diagnostics.Metrics` namespace and are used to collect and record metrics for monitoring and diagnostic purposes.
- `System.Diagnostics.Metrics`  are the newest cross-platform APIs and are compatible with the OpenTelemetry project


## Adding metrics to ProductsAPI

1. Add MetricsService class
   

2. add MetricsMiddleware class
3. Register the metricService class as singleton
```c#
builder.Services.AddSingleton<MetricsService>();

```

4. In Program.cs, register the middleware

```c#
app.UseMetricsMiddleware();
```

You will notice that you get some things written in the app console window.


### Viewing metrics globally

1. install the tools globally `dotnet tool update -g dotnet-counters`
2. open task manager and identify the PID of the web api app running then run:

```python
dotnet-counters monitor -p 68204 --counters Northwind.WebApi.Metrics

```
3. make several request to the webAPI and see what happens in the console

### Adding OTel

1. Install packages
2. Import Usings

```c#
using OpenTelemetry.Logs; // To use AddConsoleExporter.
using OpenTelemetry.Metrics; // To use WithMetrics.
using OpenTelemetry.Resources; // To use ResourceBuilder.
using OpenTelemetry.Trace; // To use WithTracing.

```

3. Enable openTelemetry

```c#
// Add and configure OpenTelemetry to logging and services.
const string serviceName = "ProductsAPI";
builder.Logging.AddOpenTelemetry(options =>
{
  options
    .SetResourceBuilder(ResourceBuilder.CreateDefault()
      .AddService(serviceName))
    .AddConsoleExporter();
});
builder.Services.AddOpenTelemetry()
  .ConfigureResource(resource => resource.AddService(serviceName))
  .WithTracing(tracing => tracing
    .AddAspNetCoreInstrumentation()
    .AddEntityFrameworkCoreInstrumentation()
    .AddSqlClientInstrumentation()
    .AddConsoleExporter())
  .WithMetrics(metrics => metrics
    .AddAspNetCoreInstrumentation()
    .AddConsoleExporter());

```

4. Viewing the telemetry
- Start the API
- Make a request
- watch the cmd or terminal and see the logging:
- Activity. Logs, Tags

note:: One of the most important pieces of data is the `Activity.TraceId`. Identify one for one specific GET request and then search for it, to identify the whole trace.

## Best practices

- Use structured logging
- Implement alerting and monitoring
- Implement centralized logging: You should store logs from all sources in a centralized logging system, like Serilog, that allows you to send logs to various destinations known as sinks. For example, to integrate Serilog with Elasticsearch (a distributed, RESTful search and analytics engine capable of storing and searching large amounts of data in real time), you can use the
## Resources
[https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line)

https://opentelemetry.io/docs/languages/net/exporters/

https://opentelemetry.io/docs/languages/net/

https://github.com/open-telemetry/opentelemetry-dotnet/tree/main/examples

https://learn.microsoft.com/en-us/dotnet/core/diagnostics/observability-with-otel

https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line

## Some questions

- What are some strategies to optimize logging and observability in your .NET applications?
- What does a .NET developer need to know about ILogger?
- Why is it important to understand that the message parameters of the LogX methods are message templates rather than individual messages?
- What is the difference between logs, metrics, and alerts?
- What is OpenTelemetry and why does Microsoft recommend it for .NET development?

## ADD Aspire Project